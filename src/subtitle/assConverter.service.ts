import { Model } from 'mongoose';
import { Injectable, Inject } from '@nestjs/common';

import { Subtitle } from './subtitle.schema';
import { AssSubtitle, AssData, AssStyle, AssDialogue, AssScriptInfo } from './ass/format';
import * as assCompiler from 'ass-compiler';

@Injectable()
// tslint:disable-next-line:component-class-suffix
export class AssConverterService {

    constructor(
      @Inject('Subtitle') private readonly subtitleModel: Model<Subtitle>
    ) { }

    private String2Primitive(str: string): string | number | boolean {

      if(!isNaN(str as any)){
        return parseFloat(str);
      }
      else if(str.toLowerCase() == "true" || str.toLowerCase() == "yes"){
        return true;
      }
      else if(str.toLowerCase() == "false" || str.toLowerCase() == "no"){
        return false;
      }
      else{
        return str;
      }
    }

    private milli2AssTimeFormat(milli) {
      if (isNaN(milli) || milli < 0) {
        return null;
      }

      let d, h, m, s, ms, cs;
      s = Math.floor(milli / 1000);
      m = Math.floor(s / 60);
      s = s % 60;
      h = Math.floor(m / 60);
      m = m % 60;
      d = Math.floor(h / 24);
      h = h % 24;
      ms = Math.floor((milli % 1000) * 1000) / 1000;
	    cs = Math.round(ms / 10);

      // format = Hrs:Mins:Secs:hundredths
      let Hrs = (d * 24 + h).toString().padStart(1, '0');
      let Mins = m.toString().padStart(2, '0');
      let Secs = s.toString().padStart(2, '0');
      let hundredths = cs.toString().padStart(2, '0');

      return Hrs +':'+ Mins +':'+ Secs +'.'+ hundredths
    }

    private Seconds2Milli(seconds:number): number {
      return seconds * 1000;
    }

    Subtitle2AssString(sub: AssSubtitle): string {

      let assString = "[Script Info]\n;Script generated by MSS\n";

      for(let scriptInfoItem of sub.data.scriptInfo){

        let value;

        if(typeof scriptInfoItem.value === 'boolean'){
          //.ass files use 0 and 1 instead of true and false
          value = scriptInfoItem.value? "yes": "no";
        }
        else{
          value = scriptInfoItem.value;
        }

        assString += scriptInfoItem.prop + ": " + value + "\n";
      }

      assString += "\n[V4+ Styles]\nFormat: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\n";

      for(let style of sub.data.styles){

        assString += "Style: ";
        let firstValue = true;
        for(let [key, value] of Object.entries(style)){
          if(key == "id") continue;
          if(value == undefined || value == null) value = "";
          if(!firstValue){
            assString += ",";
          }
          assString += value;
          firstValue = false;
        }
        assString += "\n";
      }

      assString += "\n[Events]\nFormat: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\n"

      for(let dialogue of sub.data.dialogues){

        assString += "Dialogue: ";
        let firstValue = true;
        for(let [key, value] of Object.entries(dialogue)){
          if(key == "id") continue;
          if(value == undefined || value == null) value = "";
          if(!firstValue){
            assString += ",";
          }
          if(key == "start" || key == "end"){
              assString += this.milli2AssTimeFormat(value);
          }
          else if(key == "marginL" || key == "marginR" || key == "marginV"){
              assString += value.toString().padStart(4,0)
          }
          else{
              assString += value;
          }

          firstValue = false;
        }
        assString += "\n";
      }

      return assString;
    }

    public AssString2Subtitle(assStr: string): AssSubtitle {

      let parsed = assCompiler.parse(assStr);

      let dialogues:AssDialogue[] = [];
      let lastDialogueId = 0;
      let styles:AssStyle[] = [];
      let lastStyleId = 0;

      let scriptInfo:AssScriptInfo[] = []
      let assData:AssData;

      if(parsed.info){
        for(let [prop, value] of Object.entries(parsed.info)){
          scriptInfo.push({
            prop: prop,
            value: this.String2Primitive(value as string)
          });
        }
      }

      if(parsed.styles && parsed.styles.style){
        parsed.styles.style.map(style => {

          let styleObj:any = {};

          let stylePropNames = ["name","fontname","fontsize","primaryColour",
          "secondaryColour","outlineColour","backColour","bold",
          "italic","underline","strikeOut","scaleX","scaleY",
          "spacing","angle","borderStyle","outline","shadow","alignment",
          "marginL","marginR","marginV","encoding"]

          styleObj.id = lastStyleId++;

          for (let i = 0; i < style.length; i++) {
            styleObj[stylePropNames[i]] = this.String2Primitive(style[i]);
          }

          styles.push(styleObj);
        });
      }


      if(parsed.events && parsed.events.dialogue){
        parsed.events.dialogue.map(dialogue => {
          dialogues.push({
            id: lastDialogueId++,
            layer: dialogue.Layer,
            start: this.Seconds2Milli(dialogue.Start),
            end: this.Seconds2Milli(dialogue.End),
            style: dialogue.Style,
            name: dialogue.Name,
            marginL: dialogue.MarginL,
            marginR: dialogue.MarginR,
            marginV: dialogue.MarginV,
            effect: dialogue.Effect,
            text: dialogue.Text.raw,
          })
        });
      }

      assData = {
        scriptInfo: scriptInfo,
        dialogues: dialogues,
        lastDialogueId: --lastDialogueId,
        styles: styles,
        lastStyleId: --lastStyleId
      };

      return new this.subtitleModel({
        format: "ASS",
        original: assStr,
        data: assData
      });
    }

    ApplySubtitleToOriginalAssString(subtitle: Subtitle): string {
      if(subtitle.format != "ass") return; //TODO
      if(!subtitle.original) return;//TODO

      const lines = subtitle.original.split(/\r?\n/);

      for(let line of lines){
        line.trim();
        if (/^;/.test(line)) continue;

        if(/^Dialogue\s*:/i.test(line)){

        }
      }

      return ""; //TODO
    }

}
